[31mMessageNotUnderstood: Circle>>initializeWidth:
[0mCircle(Object)>>doesNotUnderstand: #initializeWidth:
Circle class(Figure class)>>width:
FigureTest>>setUp
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: Circle>>initializeWidth:
[0mCircle(Object)>>doesNotUnderstand: #initializeWidth:
Circle class(Figure class)>>width:
FigureTest>>setUp
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: Circle>>initializeWidth:
[0mCircle(Object)>>doesNotUnderstand: #initializeWidth:
Circle class(Figure class)>>width:
Circle class>>width:
FigureTest>>setUp
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: receiver of "area" is nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #area
FigureTest>>testParallelogramArea
FigureTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: Parallelogram class>>width:height:
[0mParallelogram class(Object)>>doesNotUnderstand: #width:height:
FigureTest>>setUp
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: Parallelogram class>>width:height:
[0mParallelogram class(Object)>>doesNotUnderstand: #width:height:
FigureTest>>setUp
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: receiver of "adaptToNumber:andSend:" is nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>*
SmallInteger>>*
Square(Parallelogram)>>area
FigureTest>>testSquareArea
FigureTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: receiver of "adaptToNumber:andSend:" is nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>*
SmallInteger>>*
Square(Parallelogram)>>area
FigureTest>>testSquareArea
FigureTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m[31mMessageNotUnderstood: False>>*
[0mFalse(Object)>>doesNotUnderstand: #*
FigureTest>>testParallelogramPerimeter
FigureTest(TestCase)>>performTest
[ 
self setUp.
self performTest ] in FigureTest(TestCase)>>runCase in Block: [ ...
BlockClosure>>ensure:
FigureTest(TestCase)>>runCase
[ (self class selector: testSelector) runCase ] in FigureTest(TestCase)>>debug in Block: [ (self class selector: testSelector) runCase ]
BlockClosure>>ensure:
FigureTest(TestCase)>>debug
FigureTest class(TestCase class)>>debug:
[ 
| vScroll testClass testResult |
vScroll := methodWidget vScrollValue.
testClass := testMethod methodClass.
testResult := [ testClass run: testMethod selector ]
	on: Halt
	do: [ :e | 
		aBoolean
			ifTrue: [ 
				[ self runTestForAMethodWithAnHalt: aMethod ] fork.
				shouldAnnounce := false.
				TestAsserter classForTestResult new ]
			ifFalse: [ 
				TestAsserter classForTestResult new
					addFailure: (testClass selector: testMethod selector);
					yourself ] ].
testResult updateResultsInHistory.
testSemaphoreForMethod signal.
(aBoolean and: [ testResult failures isEmpty not or: [ testResult errors isEmpty not ] ])
	ifTrue: [ testClass debug: testMethod selector ].
ClassesIconsCache removeKey: aMethod methodClass ifAbsent: [  ].
UIManager default defer: [ methodWidget vScrollValue: vScroll ] ] in PackageTreeNautilusUI(NautilusUI)>>runTestForAMethod:notifying:priority: in Block: [ ...
[ 
self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ ...
[0m